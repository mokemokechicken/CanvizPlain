// Generated by CoffeeScript 1.7.1
(function() {
  var Bezier, Canviz, CanvizEdge, CanvizEntity, CanvizGraph, CanvizImage, CanvizNode, CanvizTokenizer, Ellipse, Path, Point, Polygon, Rect, clone, debug, escapeHTML,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  CanvizTokenizer = (function() {
    function CanvizTokenizer(str) {
      this.str = str;
    }

    CanvizTokenizer.prototype.takeChars = function(num) {
      var matches, tokens;
      if (!num) {
        num = 1;
      }
      tokens = [];
      while (num--) {
        matches = this.str.match(/^(\S+)\s*/);
        if (matches) {
          this.str = this.str.substr(matches[0].length);
          tokens.push(matches[1]);
        } else {
          tokens.push(false);
        }
      }
      if (1 === tokens.length) {
        return tokens[0];
      } else {
        return tokens;
      }
    };

    CanvizTokenizer.prototype.takeNumber = function(num) {
      var tokens;
      if (!num) {
        num = 1;
      }
      if (1 === num) {
        return Number(this.takeChars());
      } else {
        tokens = this.takeChars(num);
        while (num--) {
          tokens[num] = Number(tokens[num]);
        }
        return tokens;
      }
    };

    CanvizTokenizer.prototype.takeString = function() {
      var byteCount, charCode, charCount, str;
      byteCount = Number(this.takeChars());
      charCount = 0;
      if ('-' !== this.str.charAt(0)) {
        return false;
      }
      while (0 < byteCount) {
        ++charCount;
        charCode = this.str.charCodeAt(charCount);
        if (0x80 > charCode) {
          --byteCount;
        } else if (0x800 > charCode) {
          byteCount -= 2;
        } else {
          byteCount -= 3;
        }
      }
      str = this.str.substr(1, charCount);
      this.str = this.str.substr(1 + charCount).replace(/^\s+/, '');
      return str;
    };

    return CanvizTokenizer;

  })();

  CanvizEntity = (function() {
    function CanvizEntity(defaultAttrHashName, name, canviz, rootGraph, parentGraph, immediateGraph) {
      this.defaultAttrHashName = defaultAttrHashName;
      this.name = name;
      this.canviz = canviz;
      this.rootGraph = rootGraph;
      this.parentGraph = parentGraph;
      this.immediateGraph = immediateGraph;
      this.attrs = {};
      this.drawAttrs = {};
    }

    CanvizEntity.prototype.initBB = function() {
      var matches, x, y;
      matches = this.getAttr('pos').match(/([0-9.]+),([0-9.]+)/);
      x = Math.round(matches[1]);
      y = Math.round(this.canviz.height - matches[2]);
      return this.bbRect = new Rect(x, y, x, y);
    };

    CanvizEntity.prototype.getAttr = function(attrName, escString) {
      var attrValue, graph;
      if (escString == null) {
        escString = false;
      }
      attrValue = this.attrs[attrName];
      if (attrValue == null) {
        graph = this.parentGraph;
        while (graph != null) {
          attrValue = graph[this.defaultAttrHashName][attrName];
          if (attrValue == null) {
            graph = graph.parentGraph;
          } else {
            break;
          }
        }
      }
      if (attrValue && escString) {
        attrValue = attrValue.replace(this.escStringMatchRe, (function(_this) {
          return function(match, p1) {
            switch (p1) {
              case 'N':
              case 'E':
                return _this.name;
              case 'T':
                return _this.tailNode;
              case 'H':
                return _this.headNode;
              case 'G':
                return _this.immediateGraph.name;
              case 'L':
                return _this.getAttr('label', true);
            }
            return match;
          };
        })(this));
      }
      return attrValue;
    };

    CanvizEntity.prototype.draw = function(ctx, ctxScale, redrawCanvasOnly) {
      var attrName, attrValue, b, bbDiv, closed, color, command, cx, cy, dashStyle, fill, fillColor, filled, fontFamily, fontSize, h, href, i, l, matches, numPoints, path, rx, ry, spaces, src, str, strokeColor, style, t, target, text, textAlign, textWidth, token, tokenizer, tokens, tooltip, ts, w, _, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      if (!redrawCanvasOnly) {
        this.initBB();
        bbDiv = document.createElement('div');
        this.canviz.elements.appendChild(bbDiv);
      }
      _ref = this.drawAttrs;
      for (_ in _ref) {
        command = _ref[_];
        tokenizer = new CanvizTokenizer(command);
        token = tokenizer.takeChars();
        if (token) {
          dashStyle = 'solid';
          ctx.save();
          while (token) {
            switch (token) {
              case 'E':
              case 'e':
                filled = 'E' === token;
                cx = tokenizer.takeNumber();
                cy = this.canviz.height - tokenizer.takeNumber();
                rx = tokenizer.takeNumber();
                ry = tokenizer.takeNumber();
                path = new Ellipse(cx, cy, rx, ry);
                break;
              case 'P':
              case 'p':
              case 'L':
                filled = 'P' === token;
                closed = 'L' !== token;
                numPoints = tokenizer.takeNumber();
                tokens = tokenizer.takeNumber(2 * numPoints);
                path = new Path();
                for (i = _i = 2, _ref1 = 2 * numPoints; _i < _ref1; i = _i += 2) {
                  path.addBezier([new Point(tokens[i - 2], this.canviz.height - tokens[i - 1]), new Point(tokens[i], this.canviz.height - tokens[i + 1])]);
                }
                if (closed) {
                  path.addBezier([new Point(tokens[2 * numPoints - 2], this.canviz.height - tokens[2 * numPoints - 1]), new Point(tokens[0], this.canviz.height - tokens[1])]);
                }
                break;
              case 'B':
              case 'b':
                filled = 'b' === token;
                numPoints = tokenizer.takeNumber();
                tokens = tokenizer.takeNumber(2 * numPoints);
                path = new Path();
                for (i = _j = 2, _ref2 = 2 * numPoints; _j < _ref2; i = _j += 6) {
                  path.addBezier([new Point(tokens[i - 2], this.canviz.height - tokens[i - 1]), new Point(tokens[i], this.canviz.height - tokens[i + 1]), new Point(tokens[i + 2], this.canviz.height - tokens[i + 3]), new Point(tokens[i + 4], this.canviz.height - tokens[i + 5])]);
                }
                break;
              case 'I':
                l = tokenizer.takeNumber();
                b = this.canviz.height - tokenizer.takeNumber();
                w = tokenizer.takeNumber();
                h = tokenizer.takeNumber();
                src = tokenizer.takeString();
                if (!this.canviz.images[src]) {
                  this.canviz.images[src] = new CanvizImage(this.canviz, src);
                }
                this.canviz.images[src].draw(ctx, l, b - h, w, h);
                break;
              case 'T':
                l = Math.round(ctxScale * tokenizer.takeNumber() + this.canviz.padding);
                t = Math.round(ctxScale * this.canviz.height + 2 * this.canviz.padding - (ctxScale * (tokenizer.takeNumber() + this.canviz.bbScale * fontSize) + this.canviz.padding));
                textAlign = tokenizer.takeNumber();
                textWidth = Math.round(ctxScale * tokenizer.takeNumber());
                str = tokenizer.takeString();
                if (!redrawCanvasOnly && !/^\s*$/.test(str)) {
                  while (true) {
                    matches = str.match(/[ ]([ ]+)/);
                    if (matches) {
                      spaces = ' ';
                      for (_ = _k = 0, _ref3 = matches[1].length.times; 0 <= _ref3 ? _k <= _ref3 : _k >= _ref3; _ = 0 <= _ref3 ? ++_k : --_k) {
                        spaces += '&nbsp;';
                      }
                      str = str.replace(/[ ] +/, spaces);
                    }
                    if (!matches) {
                      break;
                    }
                  }
                  href = this.getAttr('URL', true) || this.getAttr('href', true);
                  if (href) {
                    target = this.getAttr('target', true) || '_self';
                    tooltip = this.getAttr('tooltip', true) || this.getAttr('label', true);
                    text = document.createElement("a");
                    text.href = href;
                    text.target = target;
                    text.title = tooltip;
                    _ref4 = ['onclick', 'onmousedown', 'onmouseup', 'onmouseover', 'onmousemove', 'onmouseout'];
                    for (_l = 0, _len = _ref4.length; _l < _len; _l++) {
                      attrName = _ref4[_l];
                      attrValue = this.getAttr(attrName, true);
                      if (attrValue) {
                        text.writeAttribute(attrName, attrValue);
                      }
                    }
                    text.textDecoration = 'none';
                  } else {
                    text = document.createElement("span");
                  }
                  text.innerText = str;
                  ts = text.style;
                  ts.fontSize = Math.round(fontSize * ctxScale * this.canviz.bbScale) + 'px';
                  ts.fontFamily = fontFamily;
                  ts.color = strokeColor.textColor;
                  ts.position = 'absolute';
                  ts.textAlign = -1 === textAlign ? 'left' : 1 === textAlign ? 'right' : 'center';
                  ts.left = (l - (1 + textAlign) * textWidth) + 'px';
                  ts.top = t + 'px';
                  ts.width = (2 * textWidth) + 'px';
                  if (1 !== strokeColor.opacity) {
                    ts.opacity = strokeColor.opacity;
                  }
                  this.canviz.elements.appendChild(text);
                }
                break;
              case 'C':
              case 'c':
                fill = 'C' === token;
                color = this.parseColor(tokenizer.takeString());
                if (fill) {
                  fillColor = color;
                  ctx.fillStyle = color.canvasColor;
                } else {
                  strokeColor = color;
                  ctx.strokeStyle = color.canvasColor;
                }
                break;
              case 'F':
                fontSize = tokenizer.takeNumber();
                fontFamily = tokenizer.takeString();
                switch (fontFamily) {
                  case 'Times-Roman':
                    fontFamily = 'Times New Roman';
                    break;
                  case 'Courier':
                    fontFamily = 'Courier New';
                    break;
                  case 'Helvetica':
                    fontFamily = 'Arial';
                }
                break;
              case 'S':
                style = tokenizer.takeString();
                switch (style) {
                  case 'solid':
                  case 'filled':
                    1;
                    break;
                  case 'dashed':
                  case 'dotted':
                    dashStyle = style;
                    break;
                  case 'bold':
                    ctx.lineWidth = 2;
                    break;
                  default:
                    matches = style.match(/^setlinewidth\((.*)\)$/);
                    if (matches) {
                      ctx.lineWidth = Number(matches[1]);
                    } else {
                      debug('unknown style ' + style);
                    }
                }
                break;
              default:
                debug('unknown token ' + token);
                return;
            }
            if (path) {
              this.canviz.drawPath(ctx, path, filled, dashStyle);
              if (!redrawCanvasOnly) {
                this.bbRect.expandToInclude(path.getBB());
              }
              path = void 0;
            }
            token = tokenizer.takeChars();
          }
          if (!redrawCanvasOnly) {
            bbDiv.position = 'absolute';
            bbDiv.left = Math.round(ctxScale * this.bbRect.l + this.canviz.padding) + 'px';
            bbDiv.top = Math.round(ctxScale * this.bbRect.t + this.canviz.padding) + 'px';
            bbDiv.width = Math.round(ctxScale * this.bbRect.getWidth()) + 'px';
            bbDiv.height = Math.round(ctxScale * this.bbRect.getHeight()) + 'px';
          }
          ctx.restore();
        }
      }
    };

    CanvizEntity.prototype.parseColor = function(color) {
      var colorData, colorName, colorScheme, colorSchemeData, colorSchemeName, matches, parsedColor;
      parsedColor = {
        opacity: 1
      };
      if (/^#(?:[0-9a-f]{2}\s*){3,4}$/i.test(color)) {
        return this.canviz.parseHexColor(color);
      }
      matches = color.match(/^(\d+(?:\.\d+)?)[\s,]+(\d+(?:\.\d+)?)[\s,]+(\d+(?:\.\d+)?)$/);
      if (matches) {
        parsedColor.canvasColor = parsedColor.textColor = this.canviz.hsvToRgbColor(matches[1], matches[2], matches[3]);
        return parsedColor;
      }
      colorScheme = this.getAttr('colorscheme') || 'X11';
      colorName = color;
      matches = color.match(/^\/(.*)\/(.*)$/);
      if (matches) {
        if (matches[1]) {
          colorScheme = matches[1];
        }
        colorName = matches[2];
      } else {
        matches = color.match(/^\/(.*)$/);
        if (matches) {
          colorScheme = 'X11';
          colorName = matches[1];
        }
      }
      colorName = colorName.toLowerCase();
      colorSchemeName = colorScheme.toLowerCase();
      colorSchemeData = Canviz.colors[colorSchemeName];
      if (colorSchemeData) {
        colorData = colorSchemeData[colorName];
        if (colorData) {
          return this.canviz.parseHexColor('#' + colorData);
        }
      }
      colorData = Canviz.colors['fallback'][colorName];
      if (colorData) {
        return this.canviz.parseHexColor('#' + colorData);
      }
      if (!colorSchemeData) {
        debug('unknown color scheme ' + colorScheme);
      }
      debug('unknown color ' + color + '; color scheme is ' + colorScheme);
      parsedColor.canvasColor = parsedColor.textColor = '#000000';
      return parsedColor;
    };

    return CanvizEntity;

  })();

  CanvizNode = (function(_super) {
    __extends(CanvizNode, _super);

    function CanvizNode(name, canviz, rootGraph, parentGraph) {
      CanvizNode.__super__.constructor.call(this, 'nodeAttrs', name, canviz, rootGraph, parentGraph, parentGraph);
    }

    CanvizNode.prototype.escStringMatchRe = /\\([NGL])/g;

    return CanvizNode;

  })(CanvizEntity);

  CanvizEdge = (function(_super) {
    __extends(CanvizEdge, _super);

    function CanvizEdge(name, canviz, rootGraph, parentGraph, tailNode, headNode) {
      this.tailNode = tailNode;
      this.headNode = headNode;
      CanvizEdge.__super__.constructor.call(this, 'edgeAttrs', name, canviz, rootGraph, parentGraph, parentGraph);
    }

    CanvizEdge.prototype.escStringMatchRe = /\\([EGTHL])/g;

    return CanvizEdge;

  })(CanvizEntity);

  CanvizGraph = (function(_super) {
    __extends(CanvizGraph, _super);

    function CanvizGraph(name, canviz, rootGraph, parentGraph) {
      CanvizGraph.__super__.constructor.call(this, 'attrs', name, canviz, rootGraph, parentGraph, this);
      this.nodeAttrs = {};
      this.edgeAttrs = {};
      this.nodes = [];
      this.edges = [];
      this.subgraphs = [];
    }

    CanvizGraph.prototype.initBB = function() {
      var coords;
      coords = this.getAttr('bb').split(',');
      return this.bbRect = new Rect(coords[0], this.canviz.height - coords[1], coords[2], this.canviz.height - coords[3]);
    };

    CanvizGraph.prototype.draw = function(ctx, ctxScale, redrawCanvasOnly) {
      var entity, type, _i, _len, _ref, _results;
      CanvizGraph.__super__.draw.call(this, ctx, ctxScale, redrawCanvasOnly);
      _ref = [this.subgraphs, this.nodes, this.edges];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = type.length; _j < _len1; _j++) {
            entity = type[_j];
            _results1.push(entity.draw(ctx, ctxScale, redrawCanvasOnly));
          }
          return _results1;
        })());
      }
      return _results;
    };

    CanvizGraph.prototype.escStringMatchRe = /\\([GL])/g;

    return CanvizGraph;

  })(CanvizEntity);

  Canviz = (function() {
    Canviz.maxXdotVersion = "1.2";

    Canviz.colors = {
      fallback: {
        black: '000000',
        lightgrey: 'd3d3d3',
        white: 'ffffff'
      }
    };

    function Canviz(container, url, urlParams) {
      this.canvas = document.createElement('canvas');
      this.canvas.style.position = "absolute";
      if (Canviz.canvasCounter == null) {
        Canviz.canvasCounter = 0;
      }
      this.canvas.id = 'canviz_canvas_' + (++Canviz.canvasCounter);
      this.elements = document.createElement('div');
      this.elements.style.position = "absolute";
      this.container = document.getElementById(container);
      this.container.style.position = "relative";
      this.container.appendChild(this.canvas);
      this.container.appendChild(this.elements);
      this.ctx = this.canvas.getContext('2d');
      this.scale = 1;
      this.padding = 8;
      this.dashLength = 6;
      this.dotSpacing = 4;
      this.graphs = [];
      this.images = {};
      this.numImages = 0;
      this.numImagesFinished = 0;
      this.imagePath = "";
      this.idMatch = '([a-zA-Z\u0080-\uFFFF_][0-9a-zA-Z\u0080-\uFFFF_]*|-?(?:\\.\\d+|\\d+(?:\\.\\d*)?)|"(?:\\\\"|[^"])*"|<(?:<[^>]*>|[^<>]+?)+>)';
      this.nodeIdMatch = this.idMatch + '(?::' + this.idMatch + ')?(?::' + this.idMatch + ')?';
      this.graphMatchRe = new RegExp('^(strict\\s+)?(graph|digraph)(?:\\s+' + this.idMatch + ')?\\s*{$', 'i');
      this.subgraphMatchRe = new RegExp('^(?:subgraph\\s+)?' + this.idMatch + '?\\s*{$', 'i');
      this.nodeMatchRe = new RegExp('^(' + this.nodeIdMatch + ')\\s+\\[(.+)\\];$');
      this.edgeMatchRe = new RegExp('^(' + this.nodeIdMatch + '\\s*-[->]\\s*' + this.nodeIdMatch + ')\\s+\\[(.+)\\];$');
      this.attrMatchRe = new RegExp('^' + this.idMatch + '=' + this.idMatch + '(?:[,\\s]+|$)');
    }

    Canviz.prototype.setScale = function(scale) {
      this.scale = scale;
    };

    Canviz.prototype.setImagePath = function(imagePath) {
      this.imagePath = imagePath;
    };

    Canviz.prototype.parse = function(xdot) {
      var attrHash, attrName, attrValue, attrs, bb, containers, drawAttrHash, entity, entityName, i, isGraph, lastChar, line, lines, matches, rootGraph, size, _base;
      this.graphs = [];
      this.width = 0;
      this.height = 0;
      this.maxWidth = false;
      this.maxHeight = false;
      this.bbEnlarge = false;
      this.bbScale = 1;
      this.dpi = 96;
      this.bgcolor = {
        opacity: 1
      };
      this.bgcolor.canvasColor = this.bgcolor.textColor = '#ffffff';
      lines = xdot.split(/\r?\n/);
      i = 0;
      containers = [];
      while (i < lines.length) {
        line = lines[i++].replace(/^\s+/, '');
        if ('' !== line && '#' !== line.substr(0, 1)) {
          while (i < lines.length && ';' !== (lastChar = line.substr(line.length - 1, line.length)) && '{' !== lastChar && '}' !== lastChar) {
            if ('\\' === lastChar) {
              line = line.substr(0, line.length - 1);
            }
            line += lines[i++];
          }
          if (containers.length === 0) {
            matches = line.match(this.graphMatchRe);
            if (matches) {
              rootGraph = new CanvizGraph(matches[3], this);
              containers.unshift(rootGraph);
              containers[0].strict = !(!matches[1]);
              containers[0].type = 'graph' === matches[2] ? 'undirected' : 'directed';
              containers[0].attrs.xdotversion = '1.0';
              if ((_base = containers[0].attrs).bb == null) {
                _base.bb = '0,0,500,500';
              }
              this.graphs.push(containers[0]);
            }
          } else {
            matches = line.match(this.subgraphMatchRe);
            if (matches) {
              containers.unshift(new CanvizGraph(matches[1], this, rootGraph, containers[0]));
              containers[1].subgraphs.push(containers[0]);
            }
          }
          if (matches) {

          } else if ("}" === line) {
            containers.shift();
            if (0 === containers.length) {
              break;
            }
          } else {
            matches = line.match(this.nodeMatchRe);
            if (matches) {
              entityName = matches[2];
              attrs = matches[5];
              drawAttrHash = containers[0].drawAttrs;
              isGraph = false;
              switch (entityName) {
                case 'graph':
                  attrHash = containers[0].attrs;
                  isGraph = true;
                  break;
                case 'node':
                  attrHash = containers[0].nodeAttrs;
                  break;
                case 'edge':
                  attrHash = containers[0].edgeAttrs;
                  break;
                default:
                  entity = new CanvizNode(entityName, this, rootGraph, containers[0]);
                  attrHash = entity.attrs;
                  drawAttrHash = entity.drawAttrs;
                  containers[0].nodes.push(entity);
              }
            } else {
              matches = line.match(this.edgeMatchRe);
              if (matches) {
                entityName = matches[1];
                attrs = matches[8];
                entity = new CanvizEdge(entityName, this, rootGraph, containers[0], matches[2], matches[5]);
                attrHash = entity.attrs;
                drawAttrHash = entity.drawAttrs;
                containers[0].edges.push(entity);
              }
            }
            while (matches) {
              if (0 === attrs.length) {
                break;
              }
              matches = attrs.match(this.attrMatchRe);
              if (matches) {
                attrs = attrs.substr(matches[0].length);
                attrName = matches[1];
                attrValue = this.unescape(matches[2]);
                if (/^_.*draw_$/.test(attrName)) {
                  drawAttrHash[attrName] = attrValue;
                } else {
                  attrHash[attrName] = attrValue;
                }
                if (isGraph && 1 === containers.length) {
                  switch (attrName) {
                    case 'bb':
                      bb = attrValue.split(/,/);
                      this.width = Number(bb[2]);
                      this.height = Number(bb[3]);
                      break;
                    case 'bgcolor':
                      this.bgcolor = rootGraph.parseColor(attrValue);
                      break;
                    case 'dpi':
                      this.dpi = attrValue;
                      break;
                    case 'size':
                      size = attrValue.match(/^(\d+|\d*(?:\.\d+)),\s*(\d+|\d*(?:\.\d+))(!?)$/);
                      if (size) {
                        this.maxWidth = 72 * Number(size[1]);
                        this.maxHeight = 72 * Number(size[2]);
                        this.bbEnlarge = '!' === size[3];
                      }
                      break;
                    case 'xdotversion':
                      if (0 > this.versionCompare(Canviz.maxXdotVersion, attrHash['xdotversion'])) {
                        1;
                      }
                  }
                }
              }
            }
          }
        }
      }
      return this.draw();
    };

    Canviz.prototype.draw = function(redrawCanvasOnly) {
      var ctxScale, height, width;
      if (redrawCanvasOnly == null) {
        redrawCanvasOnly = false;
      }
      ctxScale = this.scale * this.dpi / 72;
      width = Math.round(ctxScale * this.width + 2 * this.padding);
      height = Math.round(ctxScale * this.height + 2 * this.padding);
      if (!redrawCanvasOnly) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.canvas.style.width = "" + width + "px";
        this.canvas.style.height = "" + height + "px";
        this.container.style.width = "" + width + "px";
        while (this.elements.firstChild) {
          this.elements.removeChild(this.elements.firstChild);
        }
      }
      this.ctx.save();
      this.ctx.lineCap = 'round';
      this.ctx.fillStyle = this.bgcolor.canvasColor;
      this.ctx.fillRect(0, 0, width, height);
      this.ctx.translate(this.padding, this.padding);
      this.ctx.scale(ctxScale, ctxScale);
      this.graphs[0].draw(this.ctx, ctxScale, redrawCanvasOnly);
      return this.ctx.restore();
    };

    Canviz.prototype.drawPath = function(ctx, path, filled, dashStyle) {
      var oldLineWidth;
      if (filled) {
        ctx.beginPath();
        path.makePath(ctx);
        ctx.fill();
      }
      if (ctx.fillStyle !== ctx.strokeStyle || !filled) {
        switch (dashStyle) {
          case 'dashed':
            ctx.beginPath();
            path.makeDashedPath(ctx, this.dashLength);
            break;
          case 'dotted':
            oldLineWidth = ctx.lineWidth;
            ctx.lineWidth *= 2;
            ctx.beginPath();
            path.makeDottedPath(ctx, this.dotSpacing);
            break;
          default:
            if (!filled) {
              ctx.beginPath();
              path.makePath(ctx);
            }
        }
        ctx.stroke();
        if (oldLineWidth) {
          return ctx.lineWidth = oldLineWidth;
        }
      }
    };

    Canviz.prototype.unescape = function(str) {
      var matches;
      matches = str.match(/^"(.*)"$/);
      if (matches) {
        return matches[1].replace(/\\"/g, '"');
      } else {
        return str;
      }
    };

    Canviz.prototype.parseHexColor = function(color) {
      var canvasColor, matches, opacity, textColor;
      matches = color.match(/^#([0-9a-f]{2})\s*([0-9a-f]{2})\s*([0-9a-f]{2})\s*([0-9a-f]{2})?$/i);
      if (matches) {
        canvasColor;
        textColor = '#' + matches[1] + matches[2] + matches[3];
        opacity = 1;
        if (matches[4]) {
          opacity = parseInt(matches[4], 16) / 255;
          canvasColor = 'rgba(' + parseInt(matches[1], 16) + ',' + parseInt(matches[2], 16) + ',' + parseInt(matches[3], 16) + ',' + opacity + ')';
        } else {
          canvasColor = textColor;
        }
      }
      return {
        canvasColor: canvasColor,
        textColor: textColor,
        opacity: opacity
      };
    };

    Canviz.prototype.hsvToRgbColor = function(h, s, v) {
      var b, f, g, i, p, q, r, t;
      h *= 360;
      i = Math.floor(h / 60) % 6;
      f = h / 60 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
      }
      return 'rgb(' + Math.round(255 * r) + ',' + Math.round(255 * g) + ',' + Math.round(255 * b) + ')';
    };

    Canviz.prototype.versionCompare = function(a, b) {
      var a1, b1;
      a = a.split('.');
      b = b.split('.');
      while (a.length || b.length) {
        a1 = a.length ? a.shift() : 0;
        b1 = b.length ? b.shift() : 0;
        if (a1 < b1) {
          return -1;
        }
        if (a1 > b1) {
          return 1;
        }
      }
      return 0;
    };

    return Canviz;

  })();

  CanvizImage = (function() {
    function CanvizImage(canviz, src) {
      this.canviz = canviz;
      ++this.canviz.numImages;
      this.finished = this.loaded = false;
      this.img = new Image();
      this.img.onload = this.onLoad.bind(this);
      this.img.onerror = this.onFinish.bind(this);
      this.img.onabort = this.onFinish.bind(this);
      this.img.src = this.canviz.imagePath + src;
    }

    CanvizImage.prototype.onLoad = function() {
      this.loaded = true;
      return this.onFinish();
    };

    CanvizImage.prototype.onFinish = function() {
      this.finished = true;
      ++this.canviz.numImagesFinished;
      if (this.canviz.numImages === this.canviz.numImagesFinished) {
        return this.canviz.draw(true);
      }
    };

    CanvizImage.prototype.draw = function(ctx, l, t, w, h) {
      if (this.finished) {
        if (this.loaded) {
          return ctx.drawImage(this.img, l, t, w, h);
        } else {
          debug("can't load image " + this.img.src);
          return this.drawBrokenImage(ctx, l, t, w, h);
        }
      }
    };

    CanvizImage.prototype.drawBrokenImage = function(ctx, l, t, w, h) {
      ctx.save();
      ctx.beginPath();
      new Rect(l, t, l + w, t + w).draw(ctx);
      ctx.moveTo(l, t);
      ctx.lineTo(l + w, t + w);
      ctx.moveTo(l + w, t);
      ctx.lineTo(l, t + h);
      ctx.strokeStyle = '#f00';
      ctx.lineWidth = 1;
      ctx.stroke();
      return ctx.restore();
    };

    return CanvizImage;

  })();

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype.offset = function(dx, dy) {
      this.x += dx;
      return this.y += dy;
    };

    Point.prototype.distanceFrom = function(point) {
      var dx, dy;
      dx = this.x - point.x;
      dy = this.y - point.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    Point.prototype.makePath = function(ctx) {
      ctx.moveTo(this.x, this.y);
      return ctx.lineTo(this.x + 0.001, this.y);
    };

    return Point;

  })();

  Bezier = (function() {
    function Bezier(points) {
      this.points = points;
      this.order = points.length;
    }

    Bezier.prototype.reset = function() {
      var p;
      p = Bezier.prototype;
      this.controlPolygonLength = p.controlPolygonLength;
      this.chordLength = p.chordLength;
      this.triangle = p.triangle;
      this.chordPoints = p.chordPoints;
      return this.coefficients = p.coefficients;
    };

    Bezier.prototype.offset = function(dx, dy) {
      var point, _i, _len, _ref;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        point.offset(dx, dy);
      }
      return this.reset();
    };

    Bezier.prototype.getBB = function() {
      var b, l, p, point, r, rect, t, _i, _len, _ref;
      if (!this.order) {
        return void 0;
      }
      p = this.points[0];
      l = r = p.x;
      t = b = p.y;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        l = Math.min(l, point.x);
        t = Math.min(t, point.y);
        r = Math.max(r, point.x);
        b = Math.max(b, point.y);
      }
      rect = new Rect(l, t, r, b);
      return (this.getBB = function() {
        return rect;
      })();
    };

    Bezier.prototype.isPointInBB = function(x, y, tolerance) {
      var bb;
      if (tolerance == null) {
        tolerance = 0;
      }
      bb = this.getBB();
      if (0 < tolerance) {
        bb = clone(bb);
        bb.inset(-tolerance, -tolerance);
      }
      return !(x < bb.l || x > bb.r || y < bb.t || y > bb.b);
    };

    Bezier.prototype.isPointOnBezier = function(x, y, tolerance) {
      var base, bb, height, i, p1, p2, segments, twice_area, x1, x2, y1, y2, _i, _ref;
      if (tolerance == null) {
        tolerance = 0;
      }
      if (!this.isPointInBB(x, y, tolerance)) {
        return false;
      }
      segments = this.chordPoints();
      p1 = segments[0].p;
      for (i = _i = 1, _ref = segments.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        p2 = segments[i].p;
        x1 = p1.x;
        y1 = p1.y;
        x2 = p2.x;
        y2 = p2.y;
        bb = new Rect(x1, y1, x2, y2);
        if (bb.isPointInBB(x, y, tolerance)) {
          twice_area = Math.abs(x1 * y2 + x2 * y + x * y1 - x2 * y1 - x * y2 - x1 * y);
          base = p1.distanceFrom(p2);
          height = twice_area / base;
          if (height <= tolerance) {
            return true;
          }
        }
        p1 = p2;
      }
      return false;
    };

    Bezier.prototype.controlPolygonLength = function() {
      var i, len, _i, _ref;
      len = 0;
      for (i = _i = 1, _ref = this.order; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        len += this.points[i - 1].distanceFrom(this.points[i]);
      }
      return (this.controlPolygonLength = function() {
        return len;
      })();
    };

    Bezier.prototype.chordLength = function() {
      var len;
      len = this.points[0].distanceFrom(this.points[this.order - 1]);
      return (this.chordLength = function() {
        return len;
      })();
    };

    Bezier.prototype.triangle = function() {
      var c0, c1, i, j, lower, m, upper, _i, _j, _ref, _ref1;
      upper = this.points;
      m = [upper];
      for (i = _i = 1, _ref = this.order; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        lower = [];
        for (j = _j = 0, _ref1 = this.order - i; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          c0 = upper[j];
          c1 = upper[j + 1];
          lower[j] = new Point((c0.x + c1.x) / 2, (c0.y + c1.y) / 2);
        }
        m.push(lower);
        upper = lower;
      }
      return (this.triangle = function() {
        return m;
      })();
    };

    Bezier.prototype.triangleAtT = function(t) {
      var c0, c1, i, j, lower, m, s, upper, _i, _j, _ref, _ref1;
      s = 1 - t;
      upper = this.points;
      m = [upper];
      for (i = _i = 1, _ref = this.order; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        lower = [];
        for (j = _j = 0, _ref1 = this.order - i; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          c0 = upper[j];
          c1 = upper[j + 1];
          lower[j] = new Point(c0.x * s + c1.x * t, c0.y * s + c1.y * t);
        }
        m.push(lower);
        upper = lower;
      }
      return m;
    };

    Bezier.prototype.split = function(t) {
      var i, leftPoints, m, rightPoints, _i, _ref;
      if (t == null) {
        t = 0.5;
      }
      m = 0.5 === t ? this.triangle() : this.triangleAtT(t);
      leftPoints = new Array(this.order);
      rightPoints = new Array(this.order);
      for (i = _i = 1, _ref = this.order; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        leftPoints[i] = m[i][0];
        rightPoints[i] = m[this.order - 1 - i][i];
      }
      return {
        left: new Bezier(leftPoints),
        right: new Bezier(rightPoints)
      };
    };

    Bezier.prototype.mid = function(t1, t2) {
      return this.split(t2).left.split(t1 / t2).right;
    };

    Bezier.prototype.chordPoints = function() {
      var p;
      p = [
        {
          tStart: 0,
          tEnd: 0,
          dt: 0,
          p: this.points[0]
        }
      ].concat(this._chordPoints(0, 1));
      return (this.chordPoints = function() {
        return p;
      })();
    };

    Bezier.prototype._chordPoints = function(tStart, tEnd) {
      var dt, halves, tMid, tolerance;
      tolerance = 0.001;
      dt = tEnd - tStart;
      if (this.controlPolygonLength() <= (1 + tolerance) * this.chordLength()) {
        return [
          {
            tStart: tStart,
            tEnd: tEnd,
            dt: dt,
            p: this.points[this.order - 1]
          }
        ];
      } else {
        tMid = tStart + dt / 2;
        halves = this.split();
        return halves.left._chordPoints(tStart, tMid).concat(halves.right._chordPoints(tMid, tEnd));
      }
    };

    Bezier.prototype.markedEvery = function(distance, firstDistance) {
      var dt, i, nextDistance, segment, segments, t, times, _i, _ref;
      nextDistance = firstDistance || distance;
      segments = this.chordPoints();
      times = [];
      t = 0;
      for (i = _i = 1, _ref = segments.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        segment = segments[i];
        segment.length = segment.p.distanceFrom(segments[i - 1].p);
        if (0 === segment.length) {
          t += segment.dt;
        } else {
          dt = nextDistance / segment.length * segment.dt;
          segment.remainingLength = segment.length;
          while (segment.remainingLength >= nextDistance) {
            segment.remainingLength -= nextDistance;
            t += dt;
            times.push(t);
            if (distance !== nextDistance) {
              nextDistance = distance;
              dt = nextDistance / segment.length * segment.dt;
            }
          }
          nextDistance -= segment.remainingLength;
          t = segment.tEnd;
        }
      }
      return {
        times: times,
        nextDistance: nextDistance
      };
    };

    Bezier.prototype.coefficients = function() {
      var collapse, interpolate, pt, result, xps, yps, _i, _len, _ref;
      interpolate = function(p0, p1) {
        var i, p, _i, _ref;
        p0.push(0);
        p = new Array(p0.length);
        p[0] = p0[0];
        for (i = _i = 0, _ref = p1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          p[i + 1] = p0[i + 1] + p1[i] - p0[i];
        }
        return p;
      };
      collapse = function(ns) {
        var i, ps, _i, _ref;
        while (ns.length > 1) {
          ps = new Array(ns.length - 1);
          for (i = _i = 0, _ref = ns.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            ps[i] = interpolate(ns[i], ns[i + 1]);
          }
          ns = ps;
        }
        return ns[0];
      };
      xps = [];
      yps = [];
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pt = _ref[_i];
        xps.push([pt.x]);
        yps.push([pt.y]);
      }
      result = {
        xs: collapse(xps),
        ys: collapse(yps)
      };
      return (this.coefficients = function() {
        return result;
      })();
    };

    Bezier.prototype.pointAtT = function(t) {
      var c, cx, cy, i, x, y, _i, _ref, _ref1;
      c = this.coefficients();
      _ref = [c.xs, c.ys], cx = _ref[0], cy = _ref[1];
      x = cx[cx.length - 1];
      y = cy[cy.length - 1];
      for (i = _i = _ref1 = cx.length; _ref1 <= 0 ? _i <= 0 : _i >= 0; i = _ref1 <= 0 ? ++_i : --_i) {
        x = x * t + cx[i];
        y = y * t + cy[i];
      }
      return new Point(x, y);
    };

    Bezier.prototype.makePath = function(ctx, moveTo) {
      var coords, fn, i, _i, _ref, _ref1;
      if (moveTo == null) {
        moveTo = true;
      }
      if (moveTo) {
        ctx.moveTo(this.points[0].x, this.points[0].y);
      }
      fn = this.pathCommands[this.order];
      if (fn) {
        coords = [];
        for (i = _i = _ref = (1 === this.order ? 0 : 1), _ref1 = this.points.length; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          coords.push(this.points[i].x);
          coords.push(this.points[i].y);
        }
        return fn.apply(ctx, coords);
      }
    };

    Bezier.prototype.pathCommands = [
      null, function(x, y) {
        return this.lineTo(x + 0.001, y);
      }, function(x, y) {
        return this.lineTo(x, y);
      }, function(x1, y1, x2, y2) {
        return this.quadraticCurveTo(x1, y1, x2, y2);
      }, function(x1, y1, x2, y2, x3, y3) {
        return this.bezierCurveTo(x1, y1, x2, y2, x3, y3);
      }
    ];

    Bezier.prototype.makeDashedPath = function(ctx, dashLength, firstDistance, drawFirst) {
      var drawLast, i, markedEvery, _i, _ref;
      if (drawFirst == null) {
        drawFirst = true;
      }
      if (!firstDistance) {
        firstDistance = dashLength;
      }
      markedEvery = this.markedEvery(dashLength, firstDistance);
      if (drawFirst) {
        markedEvery.times.unshift(0);
      }
      drawLast = markedEvery.times.length % 2;
      if (drawLast) {
        markedEvery.times.push(1);
      }
      for (i = _i = 1, _ref = markedEvery.times.length; _i < _ref; i = _i += 2) {
        this.mid(markedEvery.times[i - 1], markedEvery.times[i]).makePath(ctx);
      }
      return {
        firstDistance: markedEvery.nextDistance,
        drawFirst: drawLast
      };
    };

    Bezier.prototype.makeDottedPath = function(ctx, dotSpacing, firstDistance) {
      var markedEvery, t, _i, _len, _ref;
      if (!firstDistance) {
        firstDistance = dotSpacing;
      }
      markedEvery = this.markedEvery(dotSpacing, firstDistance);
      if (dotSpacing === firstDistance) {
        markedEvery.times.unshift(0);
      }
      _ref = markedEvery.times;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        this.pointAtT(t).makePath(ctx);
      }
      return markedEvery.nextDistance;
    };

    return Bezier;

  })();

  Path = (function() {
    function Path(segments) {
      this.segments = segments != null ? segments : [];
    }

    Path.prototype.setupSegments = function() {};

    Path.prototype.addBezier = function(pointsOrBezier) {
      return this.segments.push(pointsOrBezier instanceof Array ? new Bezier(pointsOrBezier) : pointsOrBezier);
    };

    Path.prototype.offset = function(dx, dy) {
      var segment, _i, _len, _ref, _results;
      if (0 === this.segments.length) {
        this.setupSegments();
      }
      _ref = this.segments;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        _results.push(segment.offset(dx, dy));
      }
      return _results;
    };

    Path.prototype.getBB = function() {
      var b, l, p, point, r, rect, segment, t, _i, _j, _len, _len1, _ref, _ref1;
      if (0 === this.segments.length) {
        this.setupSegments();
      }
      p = this.segments[0].points[0];
      l = r = p.x;
      t = b = p.y;
      _ref = this.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        _ref1 = segment.points;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          point = _ref1[_j];
          l = Math.min(l, point.x);
          t = Math.min(t, point.y);
          r = Math.max(r, point.x);
          b = Math.max(b, point.y);
        }
      }
      rect = new Rect(l, t, r, b);
      return (this.getBB = function() {
        return rect;
      })();
    };

    Path.prototype.isPointInBB = function(x, y, tolerance) {
      var bb;
      if (tolerance == null) {
        tolerance = 0;
      }
      bb = this.getBB();
      if (0 < tolerance) {
        bb = clone(bb);
        bb.inset(-tolerance, -tolerance);
      }
      return !(x < bb.l || x > bb.r || y < bb.t || y > bb.b);
    };

    Path.prototype.isPointOnPath = function(x, y, tolerance) {
      var result, segment, _i, _len, _ref;
      if (tolerance == null) {
        tolerance = 0;
      }
      if (!this.isPointInBB(x, y, tolerance)) {
        return false;
      }
      result = false;
      _ref = this.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        if (segment.isPointOnBezier(x, y, tolerance)) {
          result = true;
          throw $break;
        }
      }
      return result;
    };

    Path.prototype.isPointInPath = function(x, y) {
      return false;
    };

    Path.prototype.makePath = function(ctx) {
      var moveTo, segment, _i, _len, _ref, _results;
      if (0 === this.segments.length) {
        this.setupSegments();
      }
      moveTo = true;
      _ref = this.segments;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        segment.makePath(ctx, moveTo);
        _results.push(moveTo = false);
      }
      return _results;
    };

    Path.prototype.makeDashedPath = function(ctx, dashLength, firstDistance, drawFirst) {
      var info, segment, _i, _len, _ref, _results;
      if (0 === this.segments.length) {
        this.setupSegments();
      }
      info = {
        drawFirst: drawFirst == null ? true : drawFirst,
        firstDistance: firstDistance || dashLength
      };
      _ref = this.segments;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        _results.push(info = segment.makeDashedPath(ctx, dashLength, info.firstDistance, info.drawFirst));
      }
      return _results;
    };

    Path.prototype.makeDottedPath = function(ctx, dotSpacing, firstDistance) {
      var segment, _i, _len, _ref, _results;
      if (0 === this.segments.length) {
        this.setupSegments();
      }
      if (!firstDistance) {
        firstDistance = dotSpacing;
      }
      _ref = this.segments;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        _results.push(firstDistance = segment.makeDottedPath(ctx, dotSpacing, firstDistance));
      }
      return _results;
    };

    return Path;

  })();

  Polygon = (function(_super) {
    __extends(Polygon, _super);

    function Polygon(points) {
      this.points = points != null ? points : [];
      Polygon.__super__.constructor.call(this);
    }

    Polygon.prototype.setupSegments = function() {
      var i, next, p, _i, _len, _ref, _results;
      _ref = this.points;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        p = _ref[i];
        next = i + 1;
        if (this.points.length === next) {
          next = 0;
        }
        _results.push(this.addBezier([p, this.points[next]]));
      }
      return _results;
    };

    return Polygon;

  })(Path);

  Rect = (function(_super) {
    __extends(Rect, _super);

    function Rect(l, t, r, b) {
      this.l = l;
      this.t = t;
      this.r = r;
      this.b = b;
      Rect.__super__.constructor.call(this);
    }

    Rect.prototype.inset = function(ix, iy) {
      this.l += ix;
      this.t += iy;
      this.r -= ix;
      this.b -= iy;
      return this;
    };

    Rect.prototype.expandToInclude = function(rect) {
      this.l = Math.min(this.l, rect.l);
      this.t = Math.min(this.t, rect.t);
      this.r = Math.max(this.r, rect.r);
      return this.b = Math.max(this.b, rect.b);
    };

    Rect.prototype.getWidth = function() {
      return this.r - this.l;
    };

    Rect.prototype.getHeight = function() {
      return this.b - this.t;
    };

    Rect.prototype.setupSegments = function() {
      var h, w;
      w = this.getWidth();
      h = this.getHeight();
      this.points = [new Point(this.l, this.t), new Point(this.l + w, this.t), new Point(this.l + w, this.t + h), new Point(this.l, this.t + h)];
      return Rect.__super__.setupSegments.call(this);
    };

    return Rect;

  })(Polygon);

  Ellipse = (function(_super) {
    __extends(Ellipse, _super);

    Ellipse.prototype.KAPPA = 0.5522847498;

    function Ellipse(cx, cy, rx, ry) {
      this.cx = cx;
      this.cy = cy;
      this.rx = rx;
      this.ry = ry;
      Ellipse.__super__.constructor.call(this);
    }

    Ellipse.prototype.setupSegments = function() {
      this.addBezier([new Point(this.cx, this.cy - this.ry), new Point(this.cx + this.KAPPA * this.rx, this.cy - this.ry), new Point(this.cx + this.rx, this.cy - this.KAPPA * this.ry), new Point(this.cx + this.rx, this.cy)]);
      this.addBezier([new Point(this.cx + this.rx, this.cy), new Point(this.cx + this.rx, this.cy + this.KAPPA * this.ry), new Point(this.cx + this.KAPPA * this.rx, this.cy + this.ry), new Point(this.cx, this.cy + this.ry)]);
      this.addBezier([new Point(this.cx, this.cy + this.ry), new Point(this.cx - this.KAPPA * this.rx, this.cy + this.ry), new Point(this.cx - this.rx, this.cy + this.KAPPA * this.ry), new Point(this.cx - this.rx, this.cy)]);
      return this.addBezier([new Point(this.cx - this.rx, this.cy), new Point(this.cx - this.rx, this.cy - this.KAPPA * this.ry), new Point(this.cx - this.KAPPA * this.rx, this.cy - this.ry), new Point(this.cx, this.cy - this.ry)]);
    };

    return Ellipse;

  })(Path);

  escapeHTML = function(str) {
    var div;
    div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
  };

  debug = function(str) {
    return console.log(str);
  };

  clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  Canviz.colors.x11 = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    antiquewhite1: 'ffefdb',
    antiquewhite2: 'eedfcc',
    antiquewhite3: 'cdc0b0',
    antiquewhite4: '8b8378',
    aquamarine: '7fffd4',
    aquamarine1: '7fffd4',
    aquamarine2: '76eec6',
    aquamarine3: '66cdaa',
    aquamarine4: '458b74',
    azure: 'f0ffff',
    azure1: 'f0ffff',
    azure2: 'e0eeee',
    azure3: 'c1cdcd',
    azure4: '838b8b',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    bisque1: 'ffe4c4',
    bisque2: 'eed5b7',
    bisque3: 'cdb79e',
    bisque4: '8b7d6b',
    black: '000000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blue1: '0000ff',
    blue2: '0000ee',
    blue3: '0000cd',
    blue4: '00008b',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    brown1: 'ff4040',
    brown2: 'ee3b3b',
    brown3: 'cd3333',
    brown4: '8b2323',
    burlywood: 'deb887',
    burlywood1: 'ffd39b',
    burlywood2: 'eec591',
    burlywood3: 'cdaa7d',
    burlywood4: '8b7355',
    cadetblue: '5f9ea0',
    cadetblue1: '98f5ff',
    cadetblue2: '8ee5ee',
    cadetblue3: '7ac5cd',
    cadetblue4: '53868b',
    chartreuse: '7fff00',
    chartreuse1: '7fff00',
    chartreuse2: '76ee00',
    chartreuse3: '66cd00',
    chartreuse4: '458b00',
    chocolate: 'd2691e',
    chocolate1: 'ff7f24',
    chocolate2: 'ee7621',
    chocolate3: 'cd661d',
    chocolate4: '8b4513',
    coral: 'ff7f50',
    coral1: 'ff7256',
    coral2: 'ee6a50',
    coral3: 'cd5b45',
    coral4: '8b3e2f',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    cornsilk1: 'fff8dc',
    cornsilk2: 'eee8cd',
    cornsilk3: 'cdc8b1',
    cornsilk4: '8b8878',
    crimson: 'dc143c',
    cyan: '00ffff',
    cyan1: '00ffff',
    cyan2: '00eeee',
    cyan3: '00cdcd',
    cyan4: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgoldenrod1: 'ffb90f',
    darkgoldenrod2: 'eead0e',
    darkgoldenrod3: 'cd950c',
    darkgoldenrod4: '8b6508',
    darkgreen: '006400',
    darkkhaki: 'bdb76b',
    darkolivegreen: '556b2f',
    darkolivegreen1: 'caff70',
    darkolivegreen2: 'bcee68',
    darkolivegreen3: 'a2cd5a',
    darkolivegreen4: '6e8b3d',
    darkorange: 'ff8c00',
    darkorange1: 'ff7f00',
    darkorange2: 'ee7600',
    darkorange3: 'cd6600',
    darkorange4: '8b4500',
    darkorchid: '9932cc',
    darkorchid1: 'bf3eff',
    darkorchid2: 'b23aee',
    darkorchid3: '9a32cd',
    darkorchid4: '68228b',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkseagreen1: 'c1ffc1',
    darkseagreen2: 'b4eeb4',
    darkseagreen3: '9bcd9b',
    darkseagreen4: '698b69',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategray1: '97ffff',
    darkslategray2: '8deeee',
    darkslategray3: '79cdcd',
    darkslategray4: '528b8b',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deeppink1: 'ff1493',
    deeppink2: 'ee1289',
    deeppink3: 'cd1076',
    deeppink4: '8b0a50',
    deepskyblue: '00bfff',
    deepskyblue1: '00bfff',
    deepskyblue2: '00b2ee',
    deepskyblue3: '009acd',
    deepskyblue4: '00688b',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    dodgerblue1: '1e90ff',
    dodgerblue2: '1c86ee',
    dodgerblue3: '1874cd',
    dodgerblue4: '104e8b',
    firebrick: 'b22222',
    firebrick1: 'ff3030',
    firebrick2: 'ee2c2c',
    firebrick3: 'cd2626',
    firebrick4: '8b1a1a',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    gold1: 'ffd700',
    gold2: 'eec900',
    gold3: 'cdad00',
    gold4: '8b7500',
    goldenrod: 'daa520',
    goldenrod1: 'ffc125',
    goldenrod2: 'eeb422',
    goldenrod3: 'cd9b1d',
    goldenrod4: '8b6914',
    gray: 'c0c0c0',
    gray0: '000000',
    gray1: '030303',
    gray10: '1a1a1a',
    gray100: 'ffffff',
    gray11: '1c1c1c',
    gray12: '1f1f1f',
    gray13: '212121',
    gray14: '242424',
    gray15: '262626',
    gray16: '292929',
    gray17: '2b2b2b',
    gray18: '2e2e2e',
    gray19: '303030',
    gray2: '050505',
    gray20: '333333',
    gray21: '363636',
    gray22: '383838',
    gray23: '3b3b3b',
    gray24: '3d3d3d',
    gray25: '404040',
    gray26: '424242',
    gray27: '454545',
    gray28: '474747',
    gray29: '4a4a4a',
    gray3: '080808',
    gray30: '4d4d4d',
    gray31: '4f4f4f',
    gray32: '525252',
    gray33: '545454',
    gray34: '575757',
    gray35: '595959',
    gray36: '5c5c5c',
    gray37: '5e5e5e',
    gray38: '616161',
    gray39: '636363',
    gray4: '0a0a0a',
    gray40: '666666',
    gray41: '696969',
    gray42: '6b6b6b',
    gray43: '6e6e6e',
    gray44: '707070',
    gray45: '737373',
    gray46: '757575',
    gray47: '787878',
    gray48: '7a7a7a',
    gray49: '7d7d7d',
    gray5: '0d0d0d',
    gray50: '7f7f7f',
    gray51: '828282',
    gray52: '858585',
    gray53: '878787',
    gray54: '8a8a8a',
    gray55: '8c8c8c',
    gray56: '8f8f8f',
    gray57: '919191',
    gray58: '949494',
    gray59: '969696',
    gray6: '0f0f0f',
    gray60: '999999',
    gray61: '9c9c9c',
    gray62: '9e9e9e',
    gray63: 'a1a1a1',
    gray64: 'a3a3a3',
    gray65: 'a6a6a6',
    gray66: 'a8a8a8',
    gray67: 'ababab',
    gray68: 'adadad',
    gray69: 'b0b0b0',
    gray7: '121212',
    gray70: 'b3b3b3',
    gray71: 'b5b5b5',
    gray72: 'b8b8b8',
    gray73: 'bababa',
    gray74: 'bdbdbd',
    gray75: 'bfbfbf',
    gray76: 'c2c2c2',
    gray77: 'c4c4c4',
    gray78: 'c7c7c7',
    gray79: 'c9c9c9',
    gray8: '141414',
    gray80: 'cccccc',
    gray81: 'cfcfcf',
    gray82: 'd1d1d1',
    gray83: 'd4d4d4',
    gray84: 'd6d6d6',
    gray85: 'd9d9d9',
    gray86: 'dbdbdb',
    gray87: 'dedede',
    gray88: 'e0e0e0',
    gray89: 'e3e3e3',
    gray9: '171717',
    gray90: 'e5e5e5',
    gray91: 'e8e8e8',
    gray92: 'ebebeb',
    gray93: 'ededed',
    gray94: 'f0f0f0',
    gray95: 'f2f2f2',
    gray96: 'f5f5f5',
    gray97: 'f7f7f7',
    gray98: 'fafafa',
    gray99: 'fcfcfc',
    green: '00ff00',
    green1: '00ff00',
    green2: '00ee00',
    green3: '00cd00',
    green4: '008b00',
    greenyellow: 'adff2f',
    grey: 'c0c0c0',
    grey0: '000000',
    grey1: '030303',
    grey10: '1a1a1a',
    grey100: 'ffffff',
    grey11: '1c1c1c',
    grey12: '1f1f1f',
    grey13: '212121',
    grey14: '242424',
    grey15: '262626',
    grey16: '292929',
    grey17: '2b2b2b',
    grey18: '2e2e2e',
    grey19: '303030',
    grey2: '050505',
    grey20: '333333',
    grey21: '363636',
    grey22: '383838',
    grey23: '3b3b3b',
    grey24: '3d3d3d',
    grey25: '404040',
    grey26: '424242',
    grey27: '454545',
    grey28: '474747',
    grey29: '4a4a4a',
    grey3: '080808',
    grey30: '4d4d4d',
    grey31: '4f4f4f',
    grey32: '525252',
    grey33: '545454',
    grey34: '575757',
    grey35: '595959',
    grey36: '5c5c5c',
    grey37: '5e5e5e',
    grey38: '616161',
    grey39: '636363',
    grey4: '0a0a0a',
    grey40: '666666',
    grey41: '696969',
    grey42: '6b6b6b',
    grey43: '6e6e6e',
    grey44: '707070',
    grey45: '737373',
    grey46: '757575',
    grey47: '787878',
    grey48: '7a7a7a',
    grey49: '7d7d7d',
    grey5: '0d0d0d',
    grey50: '7f7f7f',
    grey51: '828282',
    grey52: '858585',
    grey53: '878787',
    grey54: '8a8a8a',
    grey55: '8c8c8c',
    grey56: '8f8f8f',
    grey57: '919191',
    grey58: '949494',
    grey59: '969696',
    grey6: '0f0f0f',
    grey60: '999999',
    grey61: '9c9c9c',
    grey62: '9e9e9e',
    grey63: 'a1a1a1',
    grey64: 'a3a3a3',
    grey65: 'a6a6a6',
    grey66: 'a8a8a8',
    grey67: 'ababab',
    grey68: 'adadad',
    grey69: 'b0b0b0',
    grey7: '121212',
    grey70: 'b3b3b3',
    grey71: 'b5b5b5',
    grey72: 'b8b8b8',
    grey73: 'bababa',
    grey74: 'bdbdbd',
    grey75: 'bfbfbf',
    grey76: 'c2c2c2',
    grey77: 'c4c4c4',
    grey78: 'c7c7c7',
    grey79: 'c9c9c9',
    grey8: '141414',
    grey80: 'cccccc',
    grey81: 'cfcfcf',
    grey82: 'd1d1d1',
    grey83: 'd4d4d4',
    grey84: 'd6d6d6',
    grey85: 'd9d9d9',
    grey86: 'dbdbdb',
    grey87: 'dedede',
    grey88: 'e0e0e0',
    grey89: 'e3e3e3',
    grey9: '171717',
    grey90: 'e5e5e5',
    grey91: 'e8e8e8',
    grey92: 'ebebeb',
    grey93: 'ededed',
    grey94: 'f0f0f0',
    grey95: 'f2f2f2',
    grey96: 'f5f5f5',
    grey97: 'f7f7f7',
    grey98: 'fafafa',
    grey99: 'fcfcfc',
    honeydew: 'f0fff0',
    honeydew1: 'f0fff0',
    honeydew2: 'e0eee0',
    honeydew3: 'c1cdc1',
    honeydew4: '838b83',
    hotpink: 'ff69b4',
    hotpink1: 'ff6eb4',
    hotpink2: 'ee6aa7',
    hotpink3: 'cd6090',
    hotpink4: '8b3a62',
    indianred: 'cd5c5c',
    indianred1: 'ff6a6a',
    indianred2: 'ee6363',
    indianred3: 'cd5555',
    indianred4: '8b3a3a',
    indigo: '4b0082',
    invis: 'fffffe00',
    ivory: 'fffff0',
    ivory1: 'fffff0',
    ivory2: 'eeeee0',
    ivory3: 'cdcdc1',
    ivory4: '8b8b83',
    khaki: 'f0e68c',
    khaki1: 'fff68f',
    khaki2: 'eee685',
    khaki3: 'cdc673',
    khaki4: '8b864e',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lavenderblush1: 'fff0f5',
    lavenderblush2: 'eee0e5',
    lavenderblush3: 'cdc1c5',
    lavenderblush4: '8b8386',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lemonchiffon1: 'fffacd',
    lemonchiffon2: 'eee9bf',
    lemonchiffon3: 'cdc9a5',
    lemonchiffon4: '8b8970',
    lightblue: 'add8e6',
    lightblue1: 'bfefff',
    lightblue2: 'b2dfee',
    lightblue3: '9ac0cd',
    lightblue4: '68838b',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightcyan1: 'e0ffff',
    lightcyan2: 'd1eeee',
    lightcyan3: 'b4cdcd',
    lightcyan4: '7a8b8b',
    lightgoldenrod: 'eedd82',
    lightgoldenrod1: 'ffec8b',
    lightgoldenrod2: 'eedc82',
    lightgoldenrod3: 'cdbe70',
    lightgoldenrod4: '8b814c',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightpink1: 'ffaeb9',
    lightpink2: 'eea2ad',
    lightpink3: 'cd8c95',
    lightpink4: '8b5f65',
    lightsalmon: 'ffa07a',
    lightsalmon1: 'ffa07a',
    lightsalmon2: 'ee9572',
    lightsalmon3: 'cd8162',
    lightsalmon4: '8b5742',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightskyblue1: 'b0e2ff',
    lightskyblue2: 'a4d3ee',
    lightskyblue3: '8db6cd',
    lightskyblue4: '607b8b',
    lightslateblue: '8470ff',
    lightslategray: '778899',
    lightslategrey: '778899',
    lightsteelblue: 'b0c4de',
    lightsteelblue1: 'cae1ff',
    lightsteelblue2: 'bcd2ee',
    lightsteelblue3: 'a2b5cd',
    lightsteelblue4: '6e7b8b',
    lightyellow: 'ffffe0',
    lightyellow1: 'ffffe0',
    lightyellow2: 'eeeed1',
    lightyellow3: 'cdcdb4',
    lightyellow4: '8b8b7a',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'ff00ff',
    magenta1: 'ff00ff',
    magenta2: 'ee00ee',
    magenta3: 'cd00cd',
    magenta4: '8b008b',
    maroon: 'b03060',
    maroon1: 'ff34b3',
    maroon2: 'ee30a7',
    maroon3: 'cd2990',
    maroon4: '8b1c62',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumorchid1: 'e066ff',
    mediumorchid2: 'd15fee',
    mediumorchid3: 'b452cd',
    mediumorchid4: '7a378b',
    mediumpurple: '9370db',
    mediumpurple1: 'ab82ff',
    mediumpurple2: '9f79ee',
    mediumpurple3: '8968cd',
    mediumpurple4: '5d478b',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    mistyrose1: 'ffe4e1',
    mistyrose2: 'eed5d2',
    mistyrose3: 'cdb7b5',
    mistyrose4: '8b7d7b',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navajowhite1: 'ffdead',
    navajowhite2: 'eecfa1',
    navajowhite3: 'cdb38b',
    navajowhite4: '8b795e',
    navy: '000080',
    navyblue: '000080',
    none: 'fffffe00',
    oldlace: 'fdf5e6',
    olivedrab: '6b8e23',
    olivedrab1: 'c0ff3e',
    olivedrab2: 'b3ee3a',
    olivedrab3: '9acd32',
    olivedrab4: '698b22',
    orange: 'ffa500',
    orange1: 'ffa500',
    orange2: 'ee9a00',
    orange3: 'cd8500',
    orange4: '8b5a00',
    orangered: 'ff4500',
    orangered1: 'ff4500',
    orangered2: 'ee4000',
    orangered3: 'cd3700',
    orangered4: '8b2500',
    orchid: 'da70d6',
    orchid1: 'ff83fa',
    orchid2: 'ee7ae9',
    orchid3: 'cd69c9',
    orchid4: '8b4789',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    palegreen1: '9aff9a',
    palegreen2: '90ee90',
    palegreen3: '7ccd7c',
    palegreen4: '548b54',
    paleturquoise: 'afeeee',
    paleturquoise1: 'bbffff',
    paleturquoise2: 'aeeeee',
    paleturquoise3: '96cdcd',
    paleturquoise4: '668b8b',
    palevioletred: 'db7093',
    palevioletred1: 'ff82ab',
    palevioletred2: 'ee799f',
    palevioletred3: 'cd6889',
    palevioletred4: '8b475d',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peachpuff1: 'ffdab9',
    peachpuff2: 'eecbad',
    peachpuff3: 'cdaf95',
    peachpuff4: '8b7765',
    peru: 'cd853f',
    pink: 'ffc0cb',
    pink1: 'ffb5c5',
    pink2: 'eea9b8',
    pink3: 'cd919e',
    pink4: '8b636c',
    plum: 'dda0dd',
    plum1: 'ffbbff',
    plum2: 'eeaeee',
    plum3: 'cd96cd',
    plum4: '8b668b',
    powderblue: 'b0e0e6',
    purple: 'a020f0',
    purple1: '9b30ff',
    purple2: '912cee',
    purple3: '7d26cd',
    purple4: '551a8b',
    red: 'ff0000',
    red1: 'ff0000',
    red2: 'ee0000',
    red3: 'cd0000',
    red4: '8b0000',
    rosybrown: 'bc8f8f',
    rosybrown1: 'ffc1c1',
    rosybrown2: 'eeb4b4',
    rosybrown3: 'cd9b9b',
    rosybrown4: '8b6969',
    royalblue: '4169e1',
    royalblue1: '4876ff',
    royalblue2: '436eee',
    royalblue3: '3a5fcd',
    royalblue4: '27408b',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    salmon1: 'ff8c69',
    salmon2: 'ee8262',
    salmon3: 'cd7054',
    salmon4: '8b4c39',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seagreen1: '54ff9f',
    seagreen2: '4eee94',
    seagreen3: '43cd80',
    seagreen4: '2e8b57',
    seashell: 'fff5ee',
    seashell1: 'fff5ee',
    seashell2: 'eee5de',
    seashell3: 'cdc5bf',
    seashell4: '8b8682',
    sienna: 'a0522d',
    sienna1: 'ff8247',
    sienna2: 'ee7942',
    sienna3: 'cd6839',
    sienna4: '8b4726',
    skyblue: '87ceeb',
    skyblue1: '87ceff',
    skyblue2: '7ec0ee',
    skyblue3: '6ca6cd',
    skyblue4: '4a708b',
    slateblue: '6a5acd',
    slateblue1: '836fff',
    slateblue2: '7a67ee',
    slateblue3: '6959cd',
    slateblue4: '473c8b',
    slategray: '708090',
    slategray1: 'c6e2ff',
    slategray2: 'b9d3ee',
    slategray3: '9fb6cd',
    slategray4: '6c7b8b',
    slategrey: '708090',
    snow: 'fffafa',
    snow1: 'fffafa',
    snow2: 'eee9e9',
    snow3: 'cdc9c9',
    snow4: '8b8989',
    springgreen: '00ff7f',
    springgreen1: '00ff7f',
    springgreen2: '00ee76',
    springgreen3: '00cd66',
    springgreen4: '008b45',
    steelblue: '4682b4',
    steelblue1: '63b8ff',
    steelblue2: '5cacee',
    steelblue3: '4f94cd',
    steelblue4: '36648b',
    tan: 'd2b48c',
    tan1: 'ffa54f',
    tan2: 'ee9a49',
    tan3: 'cd853f',
    tan4: '8b5a2b',
    thistle: 'd8bfd8',
    thistle1: 'ffe1ff',
    thistle2: 'eed2ee',
    thistle3: 'cdb5cd',
    thistle4: '8b7b8b',
    tomato: 'ff6347',
    tomato1: 'ff6347',
    tomato2: 'ee5c42',
    tomato3: 'cd4f39',
    tomato4: '8b3626',
    transparent: 'fffffe00',
    turquoise: '40e0d0',
    turquoise1: '00f5ff',
    turquoise2: '00e5ee',
    turquoise3: '00c5cd',
    turquoise4: '00868b',
    violet: 'ee82ee',
    violetred: 'd02090',
    violetred1: 'ff3e96',
    violetred2: 'ee3a8c',
    violetred3: 'cd3278',
    violetred4: '8b2252',
    wheat: 'f5deb3',
    wheat1: 'ffe7ba',
    wheat2: 'eed8ae',
    wheat3: 'cdba96',
    wheat4: '8b7e66',
    white: 'ffffff',
    whitesmoke: 'f5f5f5',
    yellow: 'ffff00',
    yellow1: 'ffff00',
    yellow2: 'eeee00',
    yellow3: 'cdcd00',
    yellow4: '8b8b00',
    yellowgreen: '9acd32'
  };

  window.Canviz = Canviz;

}).call(this);
